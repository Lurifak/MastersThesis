#Test when n=100
dataset2<-dataset[sample(10000, size=100, replace=F),]
mod_test_2 <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset2))
mypredict <- function(mod, new_data, alpha=0.05){
#Gives the first nonzero index of a vector
first_nonz_ind<-function(example_vec){
i <- 1
while (i<length(example_vec)){
if(example_vec[i]!=0)
{break}
else
{i <- i+1}
}
return(i)
}
X <- mod$model
new_form <- update(formula(mod), NULL ~.)
x_0 <- model.matrix(new_form, new_data, xlev=mod$xlevels)
ind <- first_nonz_ind(x_0)
pred<-predict.glm(mod, newdata=new_data, type="link", se.fit=T)
mle_eta_0 <- as.numeric(pred$fit)
left_wald<-pred$fit-1.96*pred$se.fit
right_wald<-pred$fit+1.96*pred$se.fit
#Defining function giving the value of eta for the desired quantile by the inverted LRT
cutoff<-function(x)
{return(proflik(x) - proflik(mle_eta_0) + qchisq(1-alpha, 1)/2)}
#Extracting response and design matrix
mat <- model.matrix(formula(mod), X)
#Name of response variable
resp_name <- all.vars(formula(mod))[1]
#Response column
response <- X[,resp_name]
#In case of the response variable being binary it has to be converted from (1 or 2) to (0 or 1):
if(is.factor(response)){response <- as.numeric(as.factor(response)) - 1}
#Defining X_star from stackexchange
X_star<-subset(mat, select = -(ind+1)) - (1/x_0[ind])*mat[,ind+1]%*%t(x_0[-ind])
#Defining the function for the profile likelihood given eta_0
proflik<-function(eta_0){
offset_star <- as.vector((1/x_0[ind]) * eta_0 * mat[,ind+1])
new_mod<-glm.fit(X_star, response, offset=offset_star, family = family(mod))
log_lik_new<-length(new_mod$coef) - new_mod$aic/2 #AIC := 2p - 2 ln L <=> ln L = p - AIC/2
return(log_lik_new)
}
# Todo - select interval in a smarter way.
left<-uniroot(cutoff, lower=2*left_wald, upper=mle_eta_0, extendInt="upX")$root
right<-uniroot(cutoff, lower=mle_eta_0, upper=2*right_wald, extendInt="downX")$root
return(c(left, right))
}
#Test when n=10000
library(ISLR)
dataset<-ISLR::Default
mod_test <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset))
summary(mod_test)
pred <- predict.glm(mod_test, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int <- c(pred$fit-1.96*pred$se.fit, pred$fit+1.96*pred$se.fit)
#95 % Wald for eta_0
conf_int
#Supposed 95% profile conf. int for eta_0
mypredict(mod_test, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
#Test when n=1000
dataset1<-dataset[sample(10000, size=1000, replace=F),]
mod_test_1 <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset1))
pred_1 <- predict.glm(mod_test_1, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_1 <- c(pred_1$fit-1.96*pred_1$se.fit, pred_1$fit+1.96*pred_1$se.fit)
conf_int_1
mypredict(mod_test_1, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
#Test when n=100
dataset2<-dataset[sample(10000, size=100, replace=F),]
mod_test_2 <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset2))
pred_2 <- predict.glm(mod_test_2, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_2 <- c(pred_2$fit-1.96*pred_2$se.fit, pred_2$fit+1.96*pred_2$se.fit)
conf_int_2
mypredict(mod_test_2, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
mod_test<-mod_test_2
m<-100
design<-subset(dataset2, select=-1)
y<-simulate(mod_test, nsim=m)
colnames(y)<-rep("default", m)
test_proflik<-rep(NA, m)
test_wald<-rep(NA,m)
oldpred<-predict(mod_test, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
for (i in 1:m){
mod_ci<-glm(formula(mod_test), family=family(mod_test), data=cbind(y[i],design))
pred<-predict(mod_ci, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_prof<-mypredict(mod_test, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
conf_int_wald<-c(pred$fit-1.96*pred$se.fit, pred$fit+1.96*pred$se.fit)
test_proflik[i] <-ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
test_wald[i] <-ifelse(conf_int_wald[1]<=oldpred$fit & oldpred$fit<=conf_int_wald[2], 1, 0)
}
sum(test_proflik)
sum(test_wald)
m<-100
design<-subset(dataset2, select=-1)
y<-simulate(mod_test, nsim=m)
colnames(y)<-rep("default", m)
test_proflik<-rep(NA, m)
test_wald<-rep(NA,m)
oldpred<-predict(mod_test, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
for (i in 1:m){
mod_ci<-glm(formula(mod_test), family=family(mod_test), data=cbind(y[i],design))
pred<-predict(mod_ci, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_prof<-mypredict(mod_test, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
conf_int_wald<-c(pred$fit-1.96*pred$se.fit, pred$fit+1.96*pred$se.fit)
test_proflik[i] <-ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
test_wald[i] <-ifelse(conf_int_wald[1]<=oldpred$fit & oldpred$fit<=conf_int_wald[2], 1, 0)
}
sum(test_proflik)
sum(test_wald)
m<-1000
design<-subset(dataset2, select=-1)
y<-simulate(mod_test, nsim=m)
colnames(y)<-rep("default", m)
test_proflik<-rep(NA, m)
test_wald<-rep(NA,m)
oldpred<-predict(mod_test, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
for (i in 1:m){
mod_ci<-glm(formula(mod_test), family=family(mod_test), data=cbind(y[i],design))
pred<-predict(mod_ci, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_prof<-mypredict(mod_test, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
conf_int_wald<-c(pred$fit-1.96*pred$se.fit, pred$fit+1.96*pred$se.fit)
test_proflik[i] <-ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
test_wald[i] <-ifelse(conf_int_wald[1]<=oldpred$fit & oldpred$fit<=conf_int_wald[2], 1, 0)
}
sum(test_proflik)
sum(test_wald)
warnings()
ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
ifelse(conf_int_prof[1]<=pred & pred<=conf_int_prof[2], 1, 0)
mypredict <- function(mod, new_data, alpha=0.05){
#Gives the first nonzero index of a vector
first_nonz_ind<-function(example_vec){
i <- 1
while (i<length(example_vec)){
if(example_vec[i]!=0)
{break}
else
{i <- i+1}
}
return(i)
}
X <- mod$model
new_form <- update(formula(mod), NULL ~.)
x_0 <- model.matrix(new_form, new_data, xlev=mod$xlevels)
ind <- first_nonz_ind(x_0)
pred<-predict.glm(mod, newdata=new_data, type="link", se.fit=T)
mle_eta_0 <- as.numeric(pred$fit)
left_wald<-pred$fit-1.96*pred$se.fit
right_wald<-pred$fit+1.96*pred$se.fit
#Defining function giving the value of eta for the desired quantile by the inverted LRT
cutoff<-function(x)
{return(proflik(x) - proflik(mle_eta_0) + qchisq(1-alpha, 1)/2)}
#Extracting response and design matrix
mat <- model.matrix(formula(mod), X)
#Name of response variable
resp_name <- all.vars(formula(mod))[1]
#Response column
response <- X[,resp_name]
#In case of the response variable being binary it has to be converted from (1 or 2) to (0 or 1):
if(is.factor(response)){response <- as.numeric(as.factor(response)) - 1}
#Defining X_star from stackexchange
X_star<-subset(mat, select = -(ind+1)) - (1/x_0[ind])*mat[,ind+1]%*%t(x_0[-ind])
#Defining the function for the profile likelihood given eta_0
proflik<-function(eta_0){
offset_star <- as.vector((1/x_0[ind]) * eta_0 * mat[,ind+1])
new_mod<-glm.fit(X_star, response, offset=offset_star, family = family(mod))
log_lik_new<-length(new_mod$coef) - new_mod$aic/2 #AIC := 2p - 2 ln L <=> ln L = p - AIC/2
return(log_lik_new)
}
# Todo - select interval in a smarter way.
left<-uniroot(cutoff, lower=2*left_wald, upper=mle_eta_0, extendInt="upX")$root
right<-uniroot(cutoff, lower=mle_eta_0, upper=2*right_wald, extendInt="downX")$root
return(c(left, right))
}
#Test when n=10000
library(ISLR)
dataset<-ISLR::Default
mod_test <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset))
summary(mod_test)
pred <- predict.glm(mod_test, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int <- c(pred$fit-1.96*pred$se.fit, pred$fit+1.96*pred$se.fit)
#95 % Wald for eta_0
conf_int
#Supposed 95% profile conf. int for eta_0
mypredict(mod_test, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
#Test when n=1000
dataset1<-dataset[sample(10000, size=1000, replace=F),]
mod_test_1 <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset1))
pred_1 <- predict.glm(mod_test_1, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_1 <- c(pred_1$fit-1.96*pred_1$se.fit, pred_1$fit+1.96*pred_1$se.fit)
conf_int_1
mypredict(mod_test_1, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
#Test when n=100
dataset2<-dataset[sample(10000, size=100, replace=F),]
mod_test_2 <- glm(default~., family=binomial(link = "logit"), data=as.data.frame(dataset2))
pred_2 <- predict.glm(mod_test_2, newdata=data.frame(student="Yes", balance=2000, income=40000), type="link", se.fit=T)
conf_int_2 <- c(pred_2$fit-1.96*pred_2$se.fit, pred_2$fit+1.96*pred_2$se.fit)
conf_int_2
mypredict(mod_test_2, new_data=data.frame(student="Yes", balance=2000, income=40000), alpha=0.05)
